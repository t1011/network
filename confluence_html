#!/usr/bin/python3
import requests
import json
from requests.auth import HTTPBasicAuth
from datetime import datetime
import re
import os

# Конфигурация для Confluence
CONFLUENCE_URL = "https://your-confluence-domain.atlassian.net/wiki/rest/api/content"
PAGE_ID = "15656567"  # Замените на ваш актуальный ID страницы
USERNAME = "your-email@example.com"
API_TOKEN = "your-api-token"

# Операторы для поиска
OPERATORS = ["megafon", "yota", "beeline", "mts", "t2"]

# Путь к файлу для хранения истории
HISTORY_FILE = "server_history.json"

def fetch_servers_by_operator(operator):
    """Получение данных о серверах для указанного оператора."""
    url = f"https://www.speedtest.net/api/js/servers?engine=js&limit=1000&search={operator}"
    filter_country = "Russia"
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        data = response.json()
    except requests.RequestException as e:
        print(f"Ошибка при запросе данных для {operator}: {e}")
        return []

    servers = []
    for server in data:
        if server["country"] == filter_country:
            url_match = re.match(r"(https?:\/\/[^\/]+:\d+)", server["url"])
            base_url = url_match.group(1) if url_match else "N/A"
            servers.append({
                "city": server["name"],
                "url": base_url,
                "id": server["id"]
            })
    
    return servers

def generate_table(operator, servers):
    """Генерация HTML-таблицы для оператора."""
    display_name = "MTS" if operator == "mts" else operator.capitalize()

    if not servers:
        return f"<h2>{display_name}</h2><p>Данные для {display_name} отсутствуют</p>"
    
    table_rows = ""
    for i, server in enumerate(sorted(servers, key=lambda x: x["city"]), 1):
        table_rows += f"<tr><td>{i}</td><td>{server['city']}</td><td>{server['url']}</td><td>{server['id']}</td></tr>"
    
    return f"""
    <h2>{display_name}</h2>
    <table>
        <tr><th>№</th><th>Город</th><th>URL</th><th>ID</th></tr>
        {table_rows}
    </table>
    """

def load_history():
    """Загрузка истории из файла."""
    if os.path.exists(HISTORY_FILE):
        with open(HISTORY_FILE, "r") as f:
            return json.load(f)
    return {}

def save_history(history, all_data):
    """Сохранение текущих данных в историю без секунд."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
    counts = {op: len(all_data[op]) for op in OPERATORS}
    
    if "megafon_yota" not in history:
        history["megafon_yota"] = []
    if "beeline" not in history:
        history["beeline"] = []
    if "mts" not in history:
        history["mts"] = []
    if "t2" not in history:
        history["t2"] = []

    history["megafon_yota"].append({"time": timestamp, "count": counts["megafon"] + counts["yota"]})
    history["beeline"].append({"time": timestamp, "count": counts["beeline"]})
    history["mts"].append({"time": timestamp, "count": counts["mts"]})
    history["t2"].append({"time": timestamp, "count": counts["t2"]})

    with open(HISTORY_FILE, "w") as f:
        json.dump(history, f, indent=4)

def generate_interactive_chart(history):
    """Генерация интерактивного графика с Chart.js."""
    # Подготовка данных для Chart.js
    categories = {
        "MegaFon + Yota": {"data": history.get("megafon_yota", []), "color": "rgba(0, 128, 0, 1)"},
        "Beeline": {"data": history.get("beeline", []), "color": "rgba(255, 255, 0, 1)"},
        "MTS": {"data": history.get("mts", []), "color": "rgba(255, 0, 0, 1)"},
        "T2": {"data": history.get("t2", []), "color": "rgba(0, 0, 0, 1)"}
    }

    times = sorted(set([entry["time"] for cat in categories.values() for entry in cat["data"]]))
    datasets = []
    for label, info in categories.items():
        counts = [next((e["count"] for e in info["data"] if e["time"] == t), None) for t in times]
        datasets.append({
            "label": label,
            "data": counts,
            "borderColor": info["color"],
            "fill": False
        })

    # HTML-код с Chart.js
    chart_html = f"""
    <html>
    <head>
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    </head>
    <body>
        <canvas id="serverChart" width="800" height="400"></canvas>
        <script>
            const ctx = document.getElementById('serverChart').getContext('2d');
            const chart = new Chart(ctx, {{
                type: 'line',
                data: {{
                    labels: {json.dumps(times)},
                    datasets: {json.dumps(datasets)}
                }},
                options: {{
                    scales: {{
                        y: {{
                            beginAtZero: true,
                            title: {{ display: true, text: 'Количество серверов' }}
                        }},
                        x: {{
                            title: {{ display: true, text: 'Время' }}
                        }}
                    }},
                    plugins: {{
                        legend: {{ position: 'top' }},
                        zoom: {{
                            zoom: {{
                                wheel: {{ enabled: true }},
                                pinch: {{ enabled: true }},
                                mode: 'x'
                            }},
                            pan: {{
                                enabled: true,
                                mode: 'x'
                            }}
                        }}
                    }}
                }}
            }});
        </script>
    </body>
    </html>
    """
    return chart_html

def upload_chart_to_confluence(chart_html):
    """Загрузка HTML-графика как вложения в Confluence."""
    attachment_url = f"{CONFLUENCE_URL}/{PAGE_ID}/child/attachment"
    headers = {"X-Atlassian-Token": "no-check"}
    files = {"file": ("chart.html", chart_html.encode('utf-8'), "text/html")}

    response = requests.get(attachment_url, auth=HTTPBasicAuth(USERNAME, API_TOKEN))
    if response.status_code == 200:
        attachments = response.json().get("results", [])
        for attachment in attachments:
            if attachment["title"] == "chart.html":
                update_url = f"{attachment_url}/{attachment['id']}/data"
                response = requests.post(
                    update_url,
                    auth=HTTPBasicAuth(USERNAME, API_TOKEN),
                    headers=headers,
                    files=files
                )
                response.raise_for_status()
                return

    response = requests.post(
        attachment_url,
        auth=HTTPBasicAuth(USERNAME, API_TOKEN),
        headers=headers,
        files=files
    )
    response.raise_for_status()

def get_current_page_version():
    """Получение текущей версии страницы."""
    page_url = f"{CONFLUENCE_URL}/{PAGE_ID}"
    try:
        response = requests.get(
            page_url,
            auth=HTTPBasicAuth(USERNAME, API_TOKEN)
        )
        response.raise_for_status()
        page_data = response.json()
        return page_data["version"]["number"]
    except requests.RequestException as e:
        print(f"Ошибка при получении версии страницы: {e}")
        return None

def update_confluence_page(content, chart_html):
    """Обновление страницы Confluence с ссылкой на HTML-график."""
    page_url = f"{CONFLUENCE_URL}/{PAGE_ID}"
    current_version = get_current_page_version()
    if current_version is None:
        print("Не удалось определить версию страницы. Обновление отменено.")
        return

    upload_chart_to_confluence(chart_html)

    current_time = datetime.now().strftime("%d.%m.%Y %H:%M:%S")
    header = f"<p>Автоматически обновляемая страница. Последнее обновление: {current_time}</p>"
    # Ссылка на вложение или встраивание через макрос HTML
    chart_link = '<p>Интерактивный график: <a href="/wiki/download/attachments/{PAGE_ID}/chart.html">Открыть график</a></p>'
    # Если есть HTML-макрос, можно попробовать: chart_inline = '<ac:structured-macro ac:name="html"><ac:plain-text-body><![CDATA[' + chart_html + ']]></ac:plain-text-body></ac:structured-macro>'
    
    full_content = header + chart_link + content

    headers = {"Content-Type": "application/json"}
    payload = {
        "id": PAGE_ID,
        "type": "page",
        "title": "Speedtest Servers by Operator",
        "body": {
            "storage": {
                "value": full_content,
                "representation": "storage"
            }
        },
        "version": {"number": current_version + 1}
    }

    try:
        response = requests.put(
            page_url,
            auth=HTTPBasicAuth(USERNAME, API_TOKEN),
            headers=headers,
            data=json.dumps(payload)
        )
        response.raise_for_status()
        print("Страница Confluence успешно обновлена.")
    except requests.RequestException as e:
        print(f"Ошибка при обновлении страницы Confluence: {e}")

def main():
    """Основная логика скрипта."""
    all_data = {}
    for operator in OPERATORS:
        print(f"Сбор данных для {operator}...")
        all_data[operator] = fetch_servers_by_operator(operator)

    history = load_history()
    save_history(history, all_data)

    chart_html = generate_interactive_chart(history)

    page_content = ""
    for operator in ["megafon", "yota", "beeline", "mts", "t2"]:
        table = generate_table(operator, all_data[operator])
        page_content += table

    update_confluence_page(page_content, chart_html)

if __name__ == "__main__":
    main()
